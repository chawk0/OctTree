#pragma once
#include "ChawkFortress.h"

#include "Vector.h"
#include "Matrix.h"
#include "Quaternion.h"
#include "Camera.h"
//#include "Engine.h"
//#include "Log.h"
#include "MatrixStack.h"
#include "Octree.h"
#include "Perlin.h"
#include "SceneObject.h"
#include "Shader.h"
//#include "Sketch.h"
#include "Texture.h"
//#include "Timer.h"

class World
{
	public:
		World();
		~World();

		void create(const char* file);
		void create(int width, int height, int depth);
		void buildOctree();
		void render(Shader* shader, bool hideTerrain);
		void saveSegment(const char* name);//, const char* file);

		void temp();

	private:
		// holds basic information about each type of voxel (soil, water, etc).  these are indexed via
		// the map with their name as the key, a std::string.
		struct Voxel
		{
			unsigned int id;
			Texture* texture;
		};
		
		// used for each VBO generated by glGenBuffers
		struct Buffer
		{
			float* data;
			unsigned int index, size, offset;
			int componentCount;
			int elementCount;
		};

		// represents the visible faces of each voxel, and is used to build render buffer
		struct FaceData
		{
			unsigned int x, y, z;
			unsigned int faceFlags;
		};

		// represents a portion of the world that is rendered as one unit (terrain layer, water layer, etc)
		struct Segment
		{
			enum DataSourceType { None = 0, File = 1, Perlin = 2 };

			string voxelName;
			//vector<int> visibleThroughTypes;
			unsigned int* visibleThroughTypes;
			unsigned int visibleThroughTypesSize;
			bool useBlend;
			DataSourceType dataSource;
			string dataFile;
			double perlinFrequency, perlinPersistence;

			// rendering stuff
			vector<FaceData> visibleVoxels;
			unsigned int faceCount;
			unsigned int vao, vbo;
			Buffer buffer;
		};
		
		void _loadVoxelDefs();
		void _loadSegments(const char* file);
		void _generateLandscape();
		void _buildRenderBuffer();
		unsigned int _computeVisibleFaces(unsigned int x, unsigned int y, unsigned int z, FaceData* fd, unsigned int* vtt, unsigned int vttSize);

		string _name;

		// world is represented as a 3D array of voxel ID's stored as 32bit signed ints
		unsigned int* _grid;
		unsigned int _width, _height, _depth;
		// holds the list of voxel definitions and world segments
		unordered_map<string, Voxel> _voxelDefs;
		unordered_map<string, Segment> _segments;
		// holds the segments, in order, for rendering.  necessary for transparency ordering
		Segment** _segmentRenderList;
		unsigned int _segmentRenderListSize;
		// sort-of hack that allows me to map a voxel id back to the segment it was generated from
		unordered_map<unsigned int, string> _segmentIDMap;

		SceneObject _object;
		Octree octree;
};

